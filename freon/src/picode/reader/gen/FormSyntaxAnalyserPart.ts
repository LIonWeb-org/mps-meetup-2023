// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import { Form, ItemGroup, SimpleItem, StringType, IntType, Type } from "../../language/gen";
import { SimpleformsSyntaxAnalyser } from "./SimpleformsSyntaxAnalyser";
import { FreNodeReference } from "@freon4dsl/core";

export class FormSyntaxAnalyserPart {
    mainAnalyser: SimpleformsSyntaxAnalyser;

    constructor(mainAnalyser: SimpleformsSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * Form = 'Form' identifier
     *	 ItemGroup* ;
     * @param branch
     * @private
     */
    public transformForm(branch: SPPTBranch): Form {
        // console.log('transformForm called: ' + branch.name);
        let __name: string;
        let __groups: ItemGroup[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[2].name !== "ItemGroup") {
            __groups = this.mainAnalyser.transformSharedPackedParseTreeList<ItemGroup>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __groups = [];
            for (const child of children) {
                __groups.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return Form.create({
            name: __name,
            groups: __groups,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ItemGroup = 'Itemgroup' identifier
     *	 'Items:'
     *	 SimpleItem* ;
     * @param branch
     * @private
     */
    public transformItemGroup(branch: SPPTBranch): ItemGroup {
        // console.log('transformItemGroup called: ' + branch.name);
        let __name: string;
        let __items: SimpleItem[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[3].name !== "SimpleItem") {
            __items = this.mainAnalyser.transformSharedPackedParseTreeList<SimpleItem>(children[3]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __items = [];
            for (const child of children) {
                __items.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return ItemGroup.create({
            name: __name,
            items: __items,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * SimpleItem = 'Item' identifier ':' Type ;
     * @param branch
     * @private
     */
    public transformSimpleItem(branch: SPPTBranch): SimpleItem {
        // console.log('transformSimpleItem called: ' + branch.name);
        let __name: string;
        let __type: Type;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __type = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry

        return SimpleItem.create({
            name: __name,
            type: __type,
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * StringType = 'string' ;
     * @param branch
     * @private
     */
    public transformStringType(branch: SPPTBranch): StringType {
        // console.log('transformStringType called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return StringType.create({
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * IntType = 'integer' ;
     * @param branch
     * @private
     */
    public transformIntType(branch: SPPTBranch): IntType {
        // console.log('transformIntType called: ' + branch.name);

        const children = this.mainAnalyser.getChildren(branch);
        return IntType.create({
            parse_location: this.mainAnalyser.location(branch)
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * Type = StringType
     *    | IntType  ;
     * @param branch
     * @private
     */
    public transformType(branch: SPPTBranch): Type {
        // console.log('transformType called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }
}
