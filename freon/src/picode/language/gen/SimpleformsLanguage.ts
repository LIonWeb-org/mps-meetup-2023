// Generated by the Freon Language Generator.
import { FreLanguage, Model, ModelUnit, Property, Concept, Interface, FreNodeReference } from "@freon4dsl/core";

import { MainModel, Form, ItemGroup, SimpleItem, Type, StringType, IntType } from "./internal";

/**
 * Creates an in-memory representation of structure of the language metamodel, used in e.g. the (de)serializer.
 */
export function initializeLanguage() {
    FreLanguage.getInstance().name = "simpleforms";
    FreLanguage.getInstance().addModel(describeMainModel());
    FreLanguage.getInstance().addUnit(describeForm());
    FreLanguage.getInstance().addConcept(describeItemGroup());
    FreLanguage.getInstance().addConcept(describeSimpleItem());
    FreLanguage.getInstance().addConcept(describeType());
    FreLanguage.getInstance().addConcept(describeStringType());
    FreLanguage.getInstance().addConcept(describeIntType());
    FreLanguage.getInstance().addInterface(describeINamedConcept());
    FreLanguage.getInstance().addReferenceCreator((name: string, type: string) => {
        return !!name ? FreNodeReference.create(name, type) : null;
    });
}

function describeMainModel(): Model {
    const model = {
        typeName: "MainModel",
        isNamespace: true,
        constructor: () => {
            return new MainModel();
        },
        properties: new Map<string, Property>()
    };
    model.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    model.properties.set("forms", {
        name: "forms",
        type: "Form",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });

    return model;
}

function describeForm(): ModelUnit {
    const modelunit = {
        typeName: "Form",
        isNamedElement: true,
        fileExtension: "for",
        constructor: () => {
            return new Form();
        },
        properties: new Map<string, Property>()
    };
    modelunit.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    modelunit.properties.set("groups", {
        name: "groups",
        type: "ItemGroup",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });

    return modelunit;
}

function describeItemGroup(): Concept {
    const concept = {
        typeName: "ItemGroup",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "ItemGroup",
        constructor: () => {
            return new ItemGroup();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("items", {
        name: "items",
        type: "SimpleItem",
        isList: true,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeSimpleItem(): Concept {
    const concept = {
        typeName: "SimpleItem",
        isAbstract: false,
        isPublic: true,
        isNamedElement: true,
        trigger: "SimpleItem",
        constructor: () => {
            return new SimpleItem();
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: []
    };
    concept.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });
    concept.properties.set("type", {
        name: "type",
        type: "Type",
        isList: false,
        isPublic: true,
        propertyKind: "part"
    });

    return concept;
}

function describeType(): Concept {
    const concept = {
        typeName: "Type",
        isAbstract: true,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "Type",
        constructor: () => {
            return null;
        },
        properties: new Map<string, Property>(),
        baseName: null,
        subConceptNames: ["StringType", "IntType"]
    };

    return concept;
}

function describeStringType(): Concept {
    const concept = {
        typeName: "StringType",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "StringType",
        constructor: () => {
            return new StringType();
        },
        properties: new Map<string, Property>(),
        baseName: "Type",
        subConceptNames: []
    };

    return concept;
}

function describeIntType(): Concept {
    const concept = {
        typeName: "IntType",
        isAbstract: false,
        isPublic: undefined,
        isNamedElement: false,
        trigger: "IntType",
        constructor: () => {
            return new IntType();
        },
        properties: new Map<string, Property>(),
        baseName: "Type",
        subConceptNames: []
    };

    return concept;
}

function describeINamedConcept(): Interface {
    const intface = {
        typeName: "INamedConcept",
        isPublic: true,
        isNamedElement: true,
        properties: new Map<string, Property>(),
        subConceptNames: ["ItemGroup", "SimpleItem"]
    };
    intface.properties.set("name", {
        name: "name",
        type: "string",
        isList: false,
        isPublic: true,
        propertyKind: "primitive"
    });

    return intface;
}
